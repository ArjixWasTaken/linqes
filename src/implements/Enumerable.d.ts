import { IEnumerable } from "../interfaces/IEnumerable";
import { KeyedArray } from "../KeyedArray";
declare class EmptyGenerator<T> implements Generator<T> {
    [Symbol.iterator](): Generator<T, T, T>;
    next(...args: [] | [unknown]): IteratorResult<T, T>;
    next(...args: [] | [unknown]): IteratorResult<T, T>;
    return(value: any): IteratorResult<T, T>;
    throw(e: any): IteratorResult<T, T>;
}
export declare class Enumerable<T> extends EmptyGenerator<T> implements IEnumerable<T> {
    aggregate<TSeed, TReturn>(seed: TSeed, accumulator: (seed: TSeed, item: T) => TReturn): TReturn;
    all(predicate: (item: T) => boolean): boolean;
    any(): boolean;
    any(predicate: (item: T) => boolean): boolean;
    append(element: T): IEnumerable<T>;
    asEnumerable(): IEnumerable<T>;
    chunk(size: number): IEnumerable<Array<T>>;
    concat(source: IEnumerable<T>): IEnumerable<T>;
    contains(value: T): boolean;
    contains(value: T, comparer?: (left: T, right: T) => boolean): boolean;
    count(): number;
    count(predicate: (item: T) => boolean): number;
    distinct(): IEnumerable<T>;
    distinct(comparer: (left: T, right: T) => boolean): IEnumerable<T>;
    distinctBy<TKey>(keySelector: (item: T) => TKey): IEnumerable<T>;
    elementAt(index: number): T;
    elementAtOrDefault(index: number): T | null;
    except(source: Array<T> | IEnumerable<T>): IEnumerable<T>;
    except(source: Array<T> | IEnumerable<T>, comparer?: (left: T, right: T) => boolean): IEnumerable<T>;
    exceptBy<TKey>(source: Array<T> | IEnumerable<T>, keySelector: (item: T) => TKey): IEnumerable<T>;
    first(): T;
    first(predicate: (item: T) => boolean): T;
    firstOrDefault(): T | null;
    firstOrDefault(defaultValue: T): T | null;
    firstOrDefault(predicate: (item: T) => boolean): T | null;
    firstOrDefault(predicate: (item: T) => boolean, defaultValue: T): T | null;
    groupBy<TKey>(keySelector: (item: T) => TKey): IEnumerable<KeyedArray<T, TKey>>;
    last(): T;
    last(predicate: (item: T) => boolean): T;
    lastOrDefault(): T | null;
    lastOrDefault(defaultValue: T): T | null;
    lastOrDefault(predicate: (item: T) => boolean): T | null;
    lastOrDefault(predicate: (item: T) => boolean, defaultValue: T): T | null;
    order(): IEnumerable<T>;
    order(comparer: (current: T, exist: T) => number): IEnumerable<T>;
    orderBy<TKey>(keySelector: (item: T) => TKey): IEnumerable<T>;
    orderBy<TKey>(keySelector: (item: T) => TKey, comparer: (current: TKey, exist: TKey) => number): IEnumerable<T>;
    orderByDescending<TKey>(keySelector: (item: T) => TKey): IEnumerable<T>;
    orderByDescending<TKey>(keySelector: (item: T) => TKey, comparer: (current: TKey, exist: TKey) => number): IEnumerable<T>;
    orderDescending(): IEnumerable<T>;
    orderDescending(comparer: (current: T, exist: T) => number): IEnumerable<T>;
    prepend(element: T): IEnumerable<T>;
    reverse(): IEnumerable<T>;
    select<TReturn>(selector: ((item: T) => TReturn) | ((item: T, index: number) => TReturn)): IEnumerable<TReturn>;
    selectMany<TReturn>(selector: (item: T) => IEnumerable<TReturn>): IEnumerable<TReturn>;
    single(): T;
    single(predicate: (item: T) => boolean): T;
    singleOrDefault(): T | null;
    singleOrDefault(defaultValue: T): T | null;
    singleOrDefault(predicate: (item: T) => boolean): T | null;
    singleOrDefault(predicate: (item: T) => boolean, defaultValue: T): T | null;
    skip(count: number): IEnumerable<T>;
    skipLast(count: number): IEnumerable<T>;
    skipWhile(predicate: (item: T) => boolean): IEnumerable<T>;
    take(count: number): IEnumerable<T>;
    take(range: [start: number, end: number]): IEnumerable<T>;
    takeLast(count: number): IEnumerable<T>;
    takeWhile(predicate: ((item: T) => boolean) | ((item: T, index: number) => boolean)): IEnumerable<T>;
    toArray(): Array<T>;
    toDictionary<K, V>(keySelector: (item: T) => K, valueSelector: (item: T) => V): Map<K, V>;
    union(source: Array<T>, comparer?: (left: T, right: T) => boolean): IEnumerable<T>;
    unionBy<TKey>(source: Array<T>, keySelector: (item: T) => TKey, comparer?: (left: TKey, right: TKey) => boolean): IEnumerable<T>;
    where(predicate: ((item: T) => boolean) | ((item: T, index: number) => boolean)): IEnumerable<T>;
}
export {};
